{% extends "base.html" %}

{% block extra_data %}
{% set section = "Home" %}
{% endblock %}

{% block title %}
Justin Lubin
{% endblock %}

{% block header %}
  {% include "main-header.html" %}
{% endblock %}

{% block content %}
    <main>
      <p class="named callout">
        <span>Research Mission</span>
        <span style="font-size:1em">
          To enable scientists to write code with only domain expertise, not
          programming expertise.
        </span>
      </p>

      <p>
        Hi there, I&rsquo;m Justin!
        I am a PhD candidate in computer science advised by
        <a href="https://schasins.com/">
          Sarah E. Chasins</a>
        at UC&nbsp;Berkeley.
        I worked with
        <a href="http://people.cs.uchicago.edu/~rchugh/">
          Ravi Chugh</a> as an undergrad at UChicago.
        I am very grateful for their excellent mentorship and strive to pay it
        forward!
      </p>

      <h2>Research</h2>

      <p>
        <strong>I co-design programming systems with scientists.</strong> These
        systems empower scientists without a background in computing to write
        the code they need by themselves.  To make new user interactions
        possible in these systems, I develop <strong>programming language
        theory</strong> informed by what I learn from my <strong>deep
        embedding with domain experts</strong> and my mixed method
        human-computer interaction research.
      </p>

      <p>
        I&rsquo;m currently immersed in the world of
        <span class="special bio-special">
          <span>b</span><span>i</span><span>o</span><span>l</span><span>o</span><span>g</span><span>y</span>
        </span>
        to foster a substantive, ongoing, and reciprocal relationship between
        the fields of programming languages and experimental biology.
        I have been collaborating most closely with the lovely folks of the
        <a href="https://www.nunezlab.org/">
           Nuñez Lab</a>
        to advance research in biology and to answer the following question
        with them:
      </p>

      <p class="callout">
        How can we work with scientists to build a programming system
        <b>for</b> them and <b>with</b> them to empower them to write the code
        they need without having programming expertise?
      </p>

      <h2>Conference and Journal Publications</h2>

      <p>
        For more, please see my <a href="/assets/lubin-cv.pdf">CV</a>
        or <a href="https://scholar.jlubin.net">Google Scholar</a>!
        <span class="mod-note">
          (&#8727; = equal contribution, &dagger; = research mentee)
        </span>
      </p>

      <ul class="publications">
        <li>
          <div class="venue bio-venue">
            <p>Nat. Commun. &rsquo;25</p>
            <p class="venue-annotation">Biology paper</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1038/s41467-025-63167-x">
                Programmable epigenome editing by transient delivery of CRISPR
                epigenome editor ribonucleoproteins</a>
            </h3>
            <ul class="authors">
                <li>Da Xu</li>,<li class="mod">&#8727;</li>
                <li>Swen Besselink</li>,<li class="mod">&#8727;</li>
                <li>Gokul N. Ramadoss</li>,
                <li>Philip H. Dierks</li>,
                <li class="me">Justin P. Lubin</li>,
                <li>Rithu K. Pattali</li>,
                <li>Jinna I. Brim</li>,
                <li>Anna E.  Christenson</li>,
                <li>Peter J. Colias</li>,
                <li>Izaiah J. Ornelas</li>,
                <li>Carolyn D.  Nguyen</li>,
                <li>Sarah E. Chasins</li>,
                <li>Bruce R. Conklin</li>, and
                <li>James K. Nuñez</li>
            </ul>
            <ul class="links">
              <li><a href="https://github.com/Nunez-Lab/RENDER-analysis">repo</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                  Programmable epigenome editors modify gene expression in
                  mammalian cells by altering the local chromatin environment
                  at target loci without inducing DNA breaks. However, the
                  large size of CRISPR-based epigenome editors poses a
                  challenge to their broad use in biomedical research and as
                  future therapies. Here, we present Robust ENveloped Delivery
                  of Epigenome-editor Ribonucleoproteins (RENDER) for
                  transiently delivering programmable epigenetic repressors
                  (CRISPRi, DNMT3A-3L-dCas9, CRISPRoff) and activator
                  (TET1-dCas9) as ribonucleoprotein complexes into human cells
                  to modulate gene expression. After rational engineering, we
                  show that RENDER induces durable epigenetic silencing of
                  endogenous genes across various human cell types, including
                  primary T cells. Additionally, we apply RENDER to
                  epigenetically repress endogenous genes in human stem
                  cell-derived neurons, including the reduction of the
                  neurodegenerative disease associated V337M-mutated Tau
                  protein.  Together, our RENDER platform advances the delivery
                  of CRISPR-based epigenome editors into human cells,
                  broadening the use of epigenome editing in fundamental
                  research and therapeutic applications.
              </p>
            </details>
          </div>
        </li>
        <li>
          <div class="venue">
            <p>PLDI &rsquo;25</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1145/3729264">
                Programming by Navigation</a>
            </h3>
            <ul class="authors">
              <li class="me">Justin Lubin</li>,
              <li>Parker Ziegler</li>, and
              <li>Sarah E. Chasins</li>
            </ul>
            <ul class="links">
              <li><a href="/assets/pldi25a.pdf">pdf</a></li>
              <li><a href="https://www.youtube.com/watch?v=H_F6epzaeBE">presentation</a></li>
              <li><a href="/assets/pldi25a-slides.pdf">slides</a></li>
              <li><a href="/assets/pldi25a-errata.pdf">errata</a></li>
              <li><a href="/assets/pldi25a-supplement.pdf">supplement</a></li>
              <li><a href="https://github.com/justinlubin/honeybee">repo</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                  When a program synthesis task starts from an ambiguous
                  specification, the synthesis process often involves an
                  iterative specification refinement process. We introduce the
                  Programming by Navigation Synthesis Problem, a new synthesis
                  problem adapted specifically for supporting iterative
                  specification refinement in order to find a
                  <em>particular</em>
                  target solution. In contrast to prior work, we prove that
                  synthesizers that solve the Programming by Navigation
                  Synthesis Problem show
                  <em>all</em>
                  valid next steps
                  (<strong class="proper-name">Strong Completeness</strong>)
                  and
                  <em>only</em>
                  valid next steps
                  (<strong class="proper-name">Strong Soundness</strong>).
                  To meet the demands of the Programming by Navigation
                  Synthesis Problem, we introduce an algorithm to turn a type
                  inhabitation oracle (in the style of classical logic) into a
                  fully constructive program synthesizer. We then define such
                  an oracle via sound compilation to Datalog. Our empirical
                  evaluation shows that this technique results in an efficient
                  Programming by Navigation synthesizer that solves tasks that
                  are either impossible or too large for baselines to solve.
                  Our synthesizer is the first to guarantee that its
                  specification refinement process satisfies both
                  <strong class="proper-name">Strong Completeness</strong>
                  and
                  <strong class="proper-name">Strong Soundness</strong>.
              </p>
            </details>
          </div>
        </li>
        <li>
          <div class="venue">
            <p>PLDI &rsquo;25</p>
          </div>
          <div>
            <h3>
               <a href="https://doi.org/10.1145/3729278">
                 Fast Direct Manipulation Programming with Patch-Reconciliation
                 Correspondence</a>
            </h3>
            <ul class="authors">
              <li>Parker Ziegler</li>,
              <li class="me">Justin Lubin</li>, and
              <li>Sarah E. Chasins</li>
            </ul>
            <ul class="links">
              <li><a href="/assets/pldi25b.pdf">pdf</a></li>
              <li><a href="https://www.youtube.com/watch?v=dW3y_OsJnUc">presentation</a></li>
              <li><a href="/assets/pldi25b-supplement.pdf">supplement</a></li>
              <li><a href="https://github.com/parkerziegler/cartokit">repo</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                Direct manipulation programming gives users a way to write
                programs without directly writing code, by using the familiar
                GUI-style interactions they know from direct manipulation
                interfaces. To date, direct manipulation programming
                environments have relied on two core components: (1)&nbsp;a
                <em>patch</em> component, which updates the program based on a
                GUI interaction, and (2)&nbsp;a <em>forward evaluator</em>, which
                executes the patched program to produce an updated program
                output. This architecture has worked for developing
                short-running programs&mdash;i.e., programs that reliably execute
                in &lt;1 second&mdash;generating outputs such as SVG and HTML
                documents. However, direct manipulation programming has not yet
                been applied to long-running programs (e.g., data
                visualization, mapping), perhaps because executing such
                programs in response to every GUI interaction would mean
                crossing outside of interactive speeds. We propose extending
                direct manipulation programming to long-running programs by
                pairing a standard <em>patch</em> component (<strong><code>patch</code></strong>) with a
                corresponding <em>reconciliation</em> component (<strong><code>recon</strong></code>).
                <strong><code>recon</code></strong>
                directly updates the program <em>output</em> in response
                to a GUI interaction, obviating the need for forward
                evaluation.
              </p>
              <p>
                We introduce corresponding
                <strong><code>patch</code></strong>
                and
                <strong><code>recon</code></strong>
                procedures for the domain of geospatial data visualization
                and prove them sound—that is, we show that the output
                produced by
                <strong><code>recon</code></strong>
                is identical to the output produced
                by forward-evaluating a
                <strong><code>patch</strong></code>-modified
                program.
                <strong><code>recon</code></strong>
                can operate both incrementally and in parallel with
                <strong><code>patch</code></strong>.
                Our implementation of our
                <strong><code>patch</code></strong>-<strong><code>recon</code></strong>
                instantiation achieves a 2.92× median reduction
                in interface latency compared to forward evaluation on a
                suite of real-world geospatial visualization tasks.
                Looking forward, our results suggest implementations based
                on
                <strong><code>patch</code></strong>-<strong><code>recon</code></strong>
                correspondence are a viable path for
                extending direct manipulation programming to additional
                programming domains.
              </p>
            </details>
          </div>
        </li>
        <li>
          <div class="venue">
            <p>PLDI &rsquo;24</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1145/3656453">
                Equivalence by Canonicalization for Synthesis-Backed Refactoring
              </a>
            </h3>
            <ul class="authors">
              <li class="me">Justin Lubin</li>,
              <li>Jeremy Ferguson</li>,<li class="mod">&#8727;&dagger;</li>
              <li>Jacob Yim</li>,<li class="mod">&#8727;&dagger;</li>
              <li>Kevin Ye</li>,<li class="mod">&#8727;&dagger;</li> and
              <li>Sarah E. Chasins</li>
            </ul>
            <ul class="links">
              <li><a href="/assets/pldi24.pdf">pdf</a></li>
              <li><a href="https://www.youtube.com/watch?v=sK_C0tEYT84">presentation</a></li>
              <li><a href="/assets/pldi24-supplement.pdf">supplement</a></li>
              <li><a href="https://github.com/justinlubin/cobbler">repo</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                We present an enumerative program synthesis framework called
                <em>component-based refactoring</em>
                that can refactor &ldquo;direct&rdquo; style code that does not
                use library components into equivalent &ldquo;combinator&rdquo;
                style code that does use library components. This framework
                introduces a sound but incomplete technique to check the
                equivalence of direct code and combinator code called
                <em>equivalence by canonicalization</em>
                that does not rely on input-output examples or logical
                specifications. Moreover, our approach can repurpose existing
                compiler optimizations, leveraging decades of research from the
                programming languages community. We instantiated our new synthesis
                framework in two contexts: (i)&nbsp;higher-order functional
                combinators such as <code>map</code> and <code>filter</code> in
                the statically-typed functional programming language Elm and
                (ii)&nbsp;high-performance numerical computing combinators
                provided by the NumPy library for Python. We implemented both
                instantiations in a tool called Cobbler and evaluated it on
                thousands of real programs to test the performance of the
                component-based refactoring framework in terms of execution time
                and output quality. Our work offers evidence that
                synthesis-backed refactoring can apply across a range of domains
                without specification beyond the input program.
              </p>
            </details>
          </div>
        </li>
        <li>
          <div class="venue">
            <p>UIST &rsquo;22</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1145/3526113.3545659">
                Exploring the Learnability of Program Synthesizers by Novice Programmers
              </a>
            </h3>
            <ul class="authors">
              <li>Dhanya Jayagopal</li>,<li class="mod">&#8727;&dagger;</li>
              <li class="me">Justin Lubin</li>,<li class="mod">&#8727;</li> and
              <li>Sarah E. Chasins</li>
            </ul>
            <ul class="links">
              <li><a href="/assets/uist22.pdf">pdf</a></li>
              <li><a href="https://youtu.be/k5e6wOPrGic">presentation</a></li>
              <li><a href="https://docs.google.com/presentation/d/e/2PACX-1vSCsAcrqda5bUufQjuCSMuFxYD5nvWrMWq0pp1uq6mPJT5oLlDKckAM2LHSD9eyps-VDxtj37fxN3vx/pub">slides</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                Modern program synthesizers are increasingly delivering on
                their promise of lightening the burden of programming by
                automatically generating code, but little research has
                addressed how we can make such systems learnable to all. In
                this work, we ask: What aspects of program synthesizers
                contribute to and detract from their learnability by novice
                programmers? We conducted a thematic analysis of 22
                observations of novice programmers, during which novices worked
                with existing program synthesizers, then participated in
                semi-structured interviews. Our findings shed light on how
                their specific points in the synthesizer design space affect
                these tools’ learnability by novice programmers, including the
                type of specification the synthesizer requires, the method of
                invoking synthesis and receiving feedback, and the size of the
                specification. We also describe common misconceptions about
                what constitutes meaningful progress and useful specifications
                for the synthesizers, as well as participants’ common behaviors
                and strategies for using these tools. From this analysis, we
                offer a set of design opportunities to inform the design of
                future program synthesizers that strive to be learnable by
                novice programmers. This work serves as a first step toward
                understanding how we can make program synthesizers more
                learnable by novices, which opens up the possibility of using
                program synthesizers in educational settings as well as
                developer tooling oriented toward novice programmers.
              </p>
            </details>
          </div>
        </li>
        <li>
          <div class="venue">
            <p>OOPSLA &rsquo;21</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1145/3485532">
                How Statically-Typed Functional Programmers Write Code
              </a>
            </h3>
            <ul class="authors">
              <li class="me">Justin Lubin</li> and
              <li>Sarah E. Chasins</li>
            </ul>
            <ul class="links">
              <li><a href="/assets/oopsla21.pdf">pdf</a></li>
              <li><a href="https://dl.acm.org/doi/10.1145/3485532#sec-supp">presentation</a></li>
              <li><a href="https://docs.google.com/presentation/d/e/2PACX-1vQlds8AF3Fa8pChmv-FvrRaha6hW-55cwSuuu8V0m35IoXzZmsr4-GRkN81qp5fJE4kn0HldBjMOJQE/pub">slides</a></li>
              <li><a href="/assets/hstfpwc-poster.pdf">poster</a></li>
            </ul>
              <details>
                <summary>Abstract</summary>
                <p>
                  How working statically-typed functional programmers write
                  code is largely understudied.  And yet, a better
                  understanding of developer practices could pave the way for
                  the design of more useful and usable tooling, more ergonomic
                  languages, and more effective on-ramps into programming
                  communities. The goal of this work is to address this
                  knowledge gap: to better understand the high-level authoring
                  patterns that statically-typed functional programmers employ.
                  We conducted a grounded theory analysis of 30 programming
                  sessions of practicing statically-typed functional
                  programmers, 15 of which also included a semi-structured
                  interview.  The theory we developed gives insight into how
                  the specific affordances of statically-typed functional
                  programming affect domain modeling, type construction,
                  focusing techniques, exploratory and reasoning strategies,
                  and expressions of intent. We conducted a set of quantitative
                  lab experiments to validate our findings, including that
                  statically-typed functional programmers often iterate between
                  editing types and expressions, that they often run their
                  compiler on code even when they know it will not successfully
                  compile, and that they make textual program edits that
                  reliably signal future edits that they intend to make.
                  Lastly, we outline the implications of our findings for
                  language and tool design. The success of this approach in
                  revealing program authorship patterns suggests that the same
                  methodology could be used to study other understudied
                  programmer populations.
                </p>
              </details>
          </div>
        </li>
        <li>
          <div class="venue">
            <p>ICFP &rsquo;20</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1145/3408991">
                Program Sketching with Live Bidirectional Evaluation
              </a>
            </h3>
            <ul class="authors">
              <li class="me">Justin Lubin</li>,
              <li>Nick Collins</li>,
              <li>Cyrus Omar</li>, and
              <li>Ravi Chugh</li>
            </ul>
            <ul class="links">
              <li><a href="/assets/icfp20.pdf">pdf</a></li>
              <li><a href="https://youtu.be/BuxQXpv7q-A?t=4385">presentation</a></li>
              <li><a href="https://docs.google.com/presentation/d/e/2PACX-1vQahAu-Jlfu55uziiV2WCUfv0YBNgbyUFZMKTH51_GKtQgcVQTds3E-ENq2TOp_2vK-PwcTAwzEPGwt/pub">slides</a></li>
              <li><a href="https://uchicago-pl.github.io/smyth/">website</a></li>
              <li><a href="/assets/bs-thesis.pdf">honors thesis</a></li>
              <li><a href="/assets/pswlbe-poster.pdf">poster</a></li>
              <li><a href="https://github.com/UChicago-PL/smyth">repo</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                We present a system called Smyth for program sketching in a
                typed functional language whereby the concrete evaluation of
                ordinary assertions gives rise to input-output examples, which
                are then used to guide the search to complete the holes. The
                key innovation, called <em>live bidirectional evaluation</em>,
                propagates examples "backward" through partially evaluated
                sketches. Live bidirectional evaluation enables Smyth to (a)
                synthesize recursive functions without trace-complete sets of
                examples and (b) specify and solve interdependent synthesis
                goals. Eliminating the trace-completeness requirement resolves
                a significant limitation faced by prior synthesis techniques
                when given partial specifications in the form of input-output
                examples.
              </p>
              <p>
                To assess the practical implications of our techniques, we ran
                several experiments on benchmarks used to evaluate Myth, a
                state-of-the-art example-based synthesis tool. First, given
                expert examples (and no partial implementations), we find that
                Smyth requires on average 66% of the number of expert examples
                required by Myth. Second, we find that Smyth is robust to
                randomly-generated examples, synthesizing many tasks with
                relatively few more random examples than those provided by an
                expert. Third, we create a suite of small sketching tasks by
                systematically employing a simple sketching strategy to the
                Myth benchmarks; we find that user-provided sketches in Smyth
                often further reduce the total specification burden (i.e. the
                combination of partial implementations and examples). Lastly,
                we find that Leon and Synquid, two state-of-the-art logic-based
                synthesis tools, fail to complete several tasks on which Smyth
                succeeds.
              </p>
            </details>
          </div>
        </li>
        <li>
          <div class="venue">
            <p>UIST &rsquo;19</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1145/3332165.3347925">
                Sketch-n-Sketch: Output-Directed Programming for SVG
              </a>
            </h3>
            <ul class="authors">
              <li>Brian Hempel</li>,
              <li class="me">Justin Lubin</li>, and
              <li>Ravi Chugh</li>
            </ul>
            <ul class="links">
              <li><a href="/assets/uist19.pdf">pdf</a></li>
              <li><a href="http://ravichugh.github.io/sketch-n-sketch/releases/uist-2019-acm-archive/">demo</a></li>
              <li><a href="https://github.com/ravichugh/sketch-n-sketch">repo</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                For creative tasks, programmers face a choice: Use a GUI and
                sacrifice flexibility, or write code and sacrifice ergonomics?
              </p>
              <p>
                To obtain both flexibility <em>and</em> ease of use, a number
                of systems have explored a workflow that we call
                <em>output-directed programming</em>. In this paradigm, direct
                manipulation of the program's graphical output corresponds to
                writing code in a general-purpose programming language, and
                edits not possible with the mouse can still be enacted through
                ordinary text edits to the program. Such capabilities provide
                hope for integrating graphical user interfaces into what are
                currently text-centric programming environments.
              </p>
              <p>
                To further advance this vision, we present a variety of new
                output-directed techniques that extend the expressive power of
                Sketch-n-Sketch, an output-directed programming system for
                creating programs that generate vector graphics. To enable
                output-directed interaction at more stages of program
                construction, we expose intermediate execution products for
                manipulation and we present a mechanism for contextual drawing.
                Looking forward to output-directed programming beyond vector
                graphics, we also offer generic refactorings through the GUI,
                and our techniques employ a domain-agnostic provenance tracing
                scheme.
              </p>
              <p>
                To demonstrate the improved expressiveness, we implement a
                dozen new parametric designs in Sketch-n-Sketch <em>without</em>
                text-based edits. Among these is the first demonstration of
                building a recursive function in an output-directed programming
                setting.
              </p>
            </details>
          </div>
        </li>
        <li>
          <div class="venue">
            <p>ICSE &rsquo;18</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1145/3180155.3180165">
                Deuce: A Lightweight User Interface for Structured Editing
              </a>
            </h3>
            <ul class="authors">
              <li>Brian Hempel</li>,
              <li class="me">Justin Lubin</li>,
              <li>Grace Lu</li>, and
              <li>Ravi Chugh</li>
            </ul>
            <ul class="links">
              <li><a href="/assets/icse18.pdf">pdf</a></li>
              <li><a href="http://ravichugh.github.io/sketch-n-sketch/releases/v0.6.2/">demo</a></li>
              <li><a href="https://github.com/ravichugh/sketch-n-sketch">repo</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                We present a structure-aware code editor, called Deuce, that is
                equipped with direct manipulation capabilities for invoking
                automated program transformations. Compared to traditional
                refactoring environments, Deuce employs a direct manipulation
                interface that is tightly integrated within a text-based
                editing workflow. In particular, Deuce draws (i) clickable
                widgets atop the source code that allow the user to
                <em>structurally select</em> the unstructured text for
                subexpressions and other relevant features, and (ii) a
                lightweight, interactive menu of potential transformations
                based on the current selections. We implement and evaluate our
                design with mostly standard transformations in the context of a
                small functional programming language. A controlled user study
                with 21 participants demonstrates that structural selection is
                preferred to a more traditional text-selection interface and
                may be faster overall once users gain experience with the tool.
                These results accord with Deuce's aim to provide human-friendly
                structural interactions on top of familiar text-based editing.
              </p>
            </details>
          </div>
        </li>
      </ul>

      <h2>Preprints</h2>

      <ul class="publications">
        <li>
          <div class="venue bio-venue">
            <p>Biology paper</p>
          </div>
          <div>
            <h3>
              <a href="https://doi.org/10.1101/2025.10.12.681832">
                  Transcriptional regulation of disease-relevant microglial
                  activation programs</a>
            </h3>
            <ul class="authors">
                <li>Amanda McQuade</li>,
                <li>Reet Mishra</li>,
                <li>Venus Hagan</li>,
                <li>Weiwei Liang</li>,
                <li>Peter J. Colias</li>,
                <li>Vincent Cele Castillo</li>,
                <li class="me">Justin P. Lubin</li>,
                <li>Verena Haage</li>,
                <li>Victoria Marshe</li>,
                <li>Masashi Fujita</li>,
                <li>Layla Gomes</li>,
                <li>Thomas Ta,</li>,
                <li>Olivia Teter</li>,
                <li>Sarah E. Chasins</li>,
                <li>Philip L. De Jager</li>,
                <li>James K. Nuñez</li>, and
                <li>Martin Kampmann</li>
            </ul>
            <ul class="links">
              <li><a href="https://www.alzforum.org/news/research-news/drivers-common-microglial-states-identified">popular press coverage</a></li>
            </ul>
            <details>
              <summary>Abstract</summary>
              <p>
                  Microglia, the brain’s innate immune cells, can adopt a wide
                  variety of activation states relevant to health and disease.
                  Dysregulation of microglial activation occurs in numerous
                  brain disorders, and driving or inhibiting specific states
                  could be therapeutic. To discover regulators of microglial
                  activation states, we conducted CRISPR interference screens
                  in iPSC-derived microglia for inhibitors and activators of
                  six microglial states.  We identified transcriptional
                  regulators for each of these states and characterized 31
                  regulators at the single-cell transcriptomic and cell-surface
                  proteome level in two distinct iPSC-derived microglia models.
                  Finally, we functionally characterized several regulators.
                  <i>STAT2</i> knockdown inhibits interferon response and
                  lysosomal function. <i>PRDM1</i> knockdown drives
                  disease-associated and lipid-rich signatures and enhanced
                  phagocytosis. <i>DNMT1</i> knockdown results in widespread
                  loss of methylation, activating negative regulators of
                  interferon signaling. These findings provide a framework to
                  direct microglial activation to selectively enrich microglial
                  activation states, define their functional outputs, and
                  inform future therapies.
              </p>
            </details>
          </div>
        </li>
      </ul>

      <h2>Fun Stuff</h2>

      <ul id="fun-stuff">
          <li>
              Stop by the
              <a href="https://elm.town">
                  Elm Town podcast</a>
              to hear a
              <a href="https://elm.town/episodes/elm-town-84-wonder-elm-all-the-way-down-with-justin-lubin">
                  lovely conversation I had</a>
              with the host, Jared M. Smith!
          </li>
          <li>
              Take a listen to some of
              <a href="music">my music</a>
              or play
              <a href="music#lampora">my small musical video game</a>!
          </li>
      </ul>
    </main>

    <footer>
        Last updated: 2025-10-23. Happy fall!! 🍂
    </footer>
{% endblock %}
