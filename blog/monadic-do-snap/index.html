




<!DOCTYPE html>

<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
JITCompiled | Do as I say: “monadic do” notation in Snap!
</title>
    <script src="https://kit.fontawesome.com/ccff81e838.js"
            crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Signika:wght@600&display=swap">
    <link rel="stylesheet" href="/reset.css">
    <link rel="stylesheet" href="/main.css">

    <!-- Favicon, courtesy of https://favicon.io/favicon-generator/ -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
            onload="renderMathInElement(document.body, { delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>
    

    <script src="/main.js"></script>
  </head>
  <body>
    <div id="wrapper">
        <canvas id="background-canvas">
        </canvas>

        <nav>
          <ul>
            <li><a class="" href="/">Home</a></li>
            <li><a class="" href="/music">Music</a></li>
            <li><a class="active" href="/blog">Blog</a></li>
          </ul>
        </nav>

        
  <header class="blog-header">
    <h1><a href="/blog">JITCompiled</a></h1>
    <p>A blog by <a href="/">Justin Lubin</a>.</p>
  </header>



        

<main id="page">
  <h2>Do as I say: “monadic do” notation in Snap!</h2>
  <p class="date">January 13, 2020</p>
  <p><a href="https://snap.berkeley.edu/">Snap!</a>
is one of the most widely-used programming languages whose primary editor is
entirely block-based. For a while, I was skeptical of its expressive
capabilities, but, after finally playing around with it myself, I realized that
it has support for some extremely expressive constructs that enable embedded
domain-specific languages. As part of
<a href="https://schasins.com/">Sarah Chasins</a>’
<a href="http://schasins.com/cs294-usable-programming-2020/">CS 294: Building User-Centered Programming Tools</a>
class, I implemented a <em>monadic do</em> construct in Snap!, similar to
<a href="https://en.wikibooks.org/wiki/Haskell/do_notation">monadic do notation in Haskell</a>
and
<a href="https://caml.inria.fr/pub/docs/manual-ocaml/bindingops.html">binding operators in OCaml</a>.</p>
<p>I explain more about how this construct works in the rest of this post (along with an example), but if you want to mess around with it live (and see the definitions of every block I use), you can do so
<a href="https://snap.berkeley.edu/snap/snap.html#present:Username=justinlubin&amp;ProjectName=monadic-do&amp;editMode&amp;noRun">here</a>!</p>
<h3 id="implementation">Implementation</h3>
<p>To implement a <em>monadic do</em> construct, I had to implement four main features, each of which builds off the previous.</p>
<h4 id="feature-1-basic-algebraic-data-type-support">Feature 1: Basic Algebraic Data Type Support</h4>
<p>I first introduced an “option” (i.e. nullable) type implemented under-the-hood as a singleton list:</p>
<p><img src="/blog-assets/monadic-do-snap/none.png" alt="The Snap! representation of &quot;None&quot;" /></p>
<p><img src="/blog-assets/monadic-do-snap/some.png" alt="The Snap! representation of &quot;Some&quot;" /></p>
<p>I also implemented pattern matching for options and lists:</p>
<p><img src="/blog-assets/monadic-do-snap/pattern-match-option.png" alt="Pattern-matching on options" /></p>
<p><img src="/blog-assets/monadic-do-snap/pattern-match-list.png" alt="Pattern-matching on lists" /></p>
<h4 id="feature-2-functor-and-monad-typeclasses">Feature 2: Functor and Monad Typeclasses</h4>
<p>Next, I introduced blocks that allow for the definition of “anonymous” functor and monad instances:</p>
<p><img src="/blog-assets/monadic-do-snap/functor.png" alt="Functor typeclass definition" /></p>
<p><img src="/blog-assets/monadic-do-snap/monad.png" alt="Monad typeclass definition" /></p>
<p>These blocks can be used to create typeclass instances that can be assigned to a variable using a normal Snap! <em>set</em> block:</p>
<p><img src="/blog-assets/monadic-do-snap/instances.png" alt="Option and monad instances for list and option" /></p>
<p>Under the hood, I represent typeclasses as a product of functions, akin to <a href="http://okmij.org/ftp/Computation/typeclass.html#dict">dictionary passing</a>. I also provide “getter” blocks that simply return the correct function in a given typeclass dictionary:</p>
<p><img src="/blog-assets/monadic-do-snap/map-list.png" alt="Accessing the map function of the list functor" /></p>
<p><img src="/blog-assets/monadic-do-snap/pure-list.png" alt="Accessing the pure function of the list monad" /></p>
<p><img src="/blog-assets/monadic-do-snap/join-list.png" alt="Accessing the join function of the list monad" /></p>
<p><img src="/blog-assets/monadic-do-snap/functor-list.png" alt="Getting the functor instance for the list monad" /></p>
<p>Using these getters, I implemented some “typeclass functions” such as <em>bind</em> for arbitrary monads:</p>
<p><img src="/blog-assets/monadic-do-snap/bind-monad.png" alt="A generic bind implementation for monads" /></p>
<p>Unfortunately, these functions require explicitly passing in the monad as an argument. Which brings me to…</p>
<h4 id="feature-3-monadic-using-notation">Feature 3: Monadic “Using” Notation</h4>
<p>As the next step toward a nice <em>monadic do</em> construct, I introduced a block that allows its subexpressions to use a particular monad <em>implicitly</em>:</p>
<p><img src="/blog-assets/monadic-do-snap/using-list.png" alt="The &quot;using&quot; block, demonstrated on the list monad" /></p>
<p>It works by setting the global variable <code>current monad</code> to the supplied monad, running the block’s subexpression, and resetting <code>current monad</code> to its previous value. For example, using this block, I implemented a <em>return</em> block that simply calls the <em>pure</em> function of <code>current monad</code> with a given argument:</p>
<p><img src="/blog-assets/monadic-do-snap/return.png" alt="A generic implementation of the return function for monads that uses the &quot;current monad&quot; variable" /></p>
<h4 id="feature-4-monadic-let-bindings">Feature 4: Monadic Let Bindings</h4>
<p>Lastly, I introduced monadic let bindings akin to <code>x &lt;- mx</code> in Haskell and <code>let* x = mx in …</code> in OCaml, which are sugar for the monadic bind operation:</p>
<p><img src="/blog-assets/monadic-do-snap/monadic-let.png" alt="A monadic let binding" /></p>
<p>These blocks only work in a <em>using</em> block because they rely on <code>current monad</code> being set properly (so that they can access its <em>bind</em> function).</p>
<p>To implement this block, I used an <em>upvar</em>, a surprisingly versatile Snap! construct that, rather than <em>consuming</em> the value of a variable passed in by a user, instead <em>provides</em> a variable to the user. (As an aside, I’ve found upvars to be a fantastic use of interesting/atypical programming language theory tailored to a specific domain that really improves developer experience.)</p>
<p>Using an upvar turned out to be a bit tricky in this context because it meant that I had to rely on mutation to set this provided variable properly, which is not how typical <em>monadic do</em> implementations desugar. In particular, I treat the body of the monadic let binding as an uninterpreted expression and perform the following desugaring:</p>
<div class="center">
  <p><code>let* x = mx in body</code> ↝ <code>mx &gt;&gt;= (fun output -&gt; (x := output; body))</code></p>

</div>
<p>Which, in Snap!, looks like this:</p>
<p><img src="/blog-assets/monadic-do-snap/upvar.png" alt="Using an upvar to define monadic let bindings" /></p>
<p>As a convenience, I also implemented <em>pure let bindings</em> to complement monadic let bindings:</p>
<p><img src="/blog-assets/monadic-do-snap/pure-let.png" alt="A pure let binding" /></p>
<h3 id="an-example">An Example</h3>
<p>Using the list monad (which simulates a collection semantics for nondeterministic choice), I implemented a simple procedure that</p>
<ol>
<li>“Nondeterministically” chooses a variable <code>x</code> from the list <code>[4, 2, 3]</code>, then</li>
<li>(Purely) sets <code>y</code> to twice the value of <code>x</code>, then</li>
<li>“Nondeterministically” chooses <code>z</code> from the list <code>[1, 2, …, y]</code>, and finally</li>
<li>Returns the triple <code>(x, y, z)</code>:</li>
</ol>
<p><img src="/blog-assets/monadic-do-snap/list-program.png" alt="An example list program" /></p>
<p>When run, this program returns all possible outputs of the procedure just described:</p>
<p><img src="/blog-assets/monadic-do-snap/list-output.png" alt="The output of the list program" /></p>

  <footer>
    <p>Return to <a href="/blog">JITCompiled home</a>.</p>
  </footer>
</main>


      </div>
  </body>
</html>
